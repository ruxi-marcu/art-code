<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation & Augmented Reality</title>

    <!-- HAMBURGER MENU  -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css">
    <link rel="stylesheet" href="../styles.css">
</head>

<body>
    <header class="p-heder"></header>

    <section class="about" id="about">
        <div class="container">
            <!-- MY PROJECTS HEADLINE  -->
            <!-- <div class="section-headline">
                <h1 class="headline">About</h1>
            </div> -->

            <!-- ABOUT TEXT  -->
            <!-- row #1 -->
            <div class="about-desc">
                <p>This section incorporates a colection of projects made for the courses Augmented Reality and Real-Time Animation.</p>
                <p>Each project has a video that was uploadeed to Youtube showing how the program runs and next to it there is a short description.</p>
                <p>Most of the programs were made using C/C++ and OpenGl and the shading was made in GLSL.</p>
                <p>There are also 2 programs made using Unity: The Semester Project for Augmented Reality and the Interactive Movie With Animated Character. </p>
            </div>
        </div>
    </section>

    <section class="projects cg-proj">
        <div class="container">
            <!-- MY PROJECTS HEADLINE  -->
            <div class="section-heading">
                <h1 class="headline">Augmented Reality</h1>
            </div>
            <div class="cg-grid-projects">
                <!-- GRID OF PROJECTS  -->
                <div class="each-proj">
                    <div class="cg-proj-headline">Semester Project</div>
                    <div class="proj-contents">
                        <div class="cg-proj-desc">
                            <p>The application is a game with image targets, developed for Android devices. 
                                The application was created using Vuforia and Unity and then deployed and tested on an Android device (Samsung Galaxy Tab S4, 10.5”).
                            </p>
                            <p>To each image target a character was attached that is being displayed on the image of the card on the application is running. In this game the characters used were provided by the Unity Asset Store and are a Barbarian Warrior and a mummy that is displayed three times on three of the targets.</p>
                            <p>The aim of the game is to destroy the three mummies by using the barbarian character, that has the ability to move and shoot axes in different directions. Once a mummy is hit by an axe a health bar appears above it that allows the user to see how much life it has left. The health bar is created by using interface elements: canvas, panel and slider that are set to always face the camera, therefore the bar will always be visible regardless of the device movement. </p>
                            <p>Both the barbarian and the three mummies use scripts to enable special actions and features. The barbarian script enables the character to instantiate new axes as the user taps on the screen. The character can also be rotated and translated by using different finger movements. For the user input the LeanTouch library was used, also downloaded from the Unity Asset Store. The application also displays a UI interface that is overlaid on top of the game in the bottom of the screen. This interface provides two extra features that can be used for the character, namely power and angle</p>
                            <p>If all enemies are destroyed an animation attached to the object is played in a loop and a melody to let the user know that he won the game.</p>
                            <p>The mummy script checks for collision between the axes thrown by the barbarian and its own box collider. If a collision occurred the current health is changed and then displayed in the heal bar. A particle system attached to the game object will be put to play and then stopped in coroutine and a sound played. If the health bar reaches 0% the game object will be destroyed and will disappear of the marker.</p>
                                <hr>
                            
                        </div>
                        <div class="cg-proj-video">
                            <iframe width="560" height="315" src="https://www.youtube.com/embed/P225OBgZAWc" frameborder="0" allow="accelerometer;
                             autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
                            </iframe>
                        </div>
                    </div>
                </div>
    
            </div>
        </div>
    </section>

    <section class="projects rr-proj">
        <div class="container">
            <!-- MY PROJECTS HEADLINE  -->
            <div class="section-heading">
                <h1 class="headline">Real-Time Animation</h1>
            </div>
            <div class="cg-grid-projects">
                <!-- GRID OF PROJECTS  -->

                <!-- Interactive Movie with Animated Character -->
                <div class="each-proj">
                    <div class="cg-proj-headline">Interactive Movie with Animated Character</div>
                    <div class="proj-contents">
                        <div class="cg-proj-desc">
                            <p>The project is created in Unity. The environment and characters were taken from the Unity Asset
                                Store.
                                The animation starts with an overview camera that films the entire scene and after which focuses on
the main character of the movie. The camera at the beginning is a Cinemachine Dolly Track camera
The camera follows the desired path and then stops in front of the character after which some State-
Driven cameras are used to follow the character how he is pushing the chest and then moving
around to sit on a rock. For the state driven camera more virtual cameras were added that are
triggered by the different animations of the character. There are cameras for walking, sitting
throwing and idle state. All these cameras are mixed with normal cameras that were added at
different times in the timeline.
The animation of the character is triggered through script and also the chest pushing was made
through script.
The cameras for the next part of the movie are Unity cameras for which animations with keyframes
were made. The order in which each camera should be active in the scene is set through a timeline.
The timeline contains the cameras used in the scene and also the soundtrack. The sounds were
added to the timeline at the particular moment when they are supposed to play.
The character, the barbarian, come with some animations but more animations were added from
Mixamo. The model was uploaded in Mixamo different animations were chosen and then exported
without mesh to be used in Unity. After importing the new animations in Unity the animations had
to be changed to humanoid mode and adapted for the character in order to work properly.
The character also uses face animations that were added on a different layer of the characters
Animator controller. For the facial animations an animation mask was created to blend together the
animations from the two different layers and therefore the facial animations could work together
with different body animations resulting in a complex movement of the character.

The skeleton has its own script and animator controller. Different camera animations were created
in order to capture the different close-ups of the two characters and emphasize the facial
movements. At this point the character shows anticipation and exaggeration through its facial
features by having exaggerated expressions that show astonishment and then fear.

The cameras show the use of ease in and ease out. They use arcs and interpolate between different
positions and rotations.
The skeleton has its own script and its own animator controller. Different animations are triggered
from the script at particular times. The skeleton is displayed idle, dragging the chest, turning and
then walking towards the main character.
Both characters are rotated by using quaternions and euler angles to rotate their game objects.
Physics with rigid body property was used to create the movement of the characters by adding
velocity to their respective rigid bodies.
After running away from the skeleton, the barbarian encounters a little mummy that exemplifies one
of the principles of animation, namely squash and stretch. This animation was created by using
keyframe animation and creating a new animation for the mummy character.
After the entire animation is played the user is left to control the main character.
Particle systems were added to the scene in the spot where the character can be controlled by the
user. When the game starts fire can be seen by the characters feet.

The character can be controlled with the keyboard and mouse. The character can walk, run and hit
with its axe.
A different script was created to incorporate the game behavior of the character. The movement of
the character was set at different speeds based on the character walking or running.
The walking and running take as input values from the keys. Different animations for walking
straight, walking to the left, to the right and backwards are blended together using blend trees. For
running a different blend tree was created that blends together the running animations. In order to
make the character run, the shift key has to be pressed while also pressing the movement keys.
The mouse triggers the attack animation of the character by making the character twirl and hit with
its axe.
If there is no input from the user, the character returns to its default pose and that animation runs in
a loop.
                            </p>
                        </div>
                        <div class="cg-proj-video">
                            <iframe width="560" height="315" src="https://www.youtube.com/embed/T1kPRARaQVU" frameborder="0" allow="accelerometer;
                             autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
                            </iframe>
                        </div>
                    </div>
                </div>

                <!-- BLEND FACES -->
                <div class="each-proj">
                    <div class="cg-proj-headline">BLEND FACES</div>
                    <div class="proj-contents">
                        <div class="cg-proj-desc">
                            <p>In the application I used as the ImGUI interface ImGUI for manipulating the weights of the blend
                                shapes.
                                All the obj models in the folder are loaded in buffers. The vertices, normals and indexes are stored
                                for every face in variables of type std::vector<glm::vec3> respectively std::vector<int>. After
                                everything is loaded all the indexed vertices are copied to a Eigen::MatrixXf. Every line of the matrix
                                will contain all the vertices for 1 face, first the x values then the y and z. The same process is applied
                                for the normal.
                            </p>
                            <p>The weights received as input from the ImGUI interface are copied in an Eigen::VectorXf. The weight
                                on position zero is always set to 1. This weould actually represent the weight of the neutral face. This
                                weight is added only to make the multiplication possible between the matrix with all the faces and
                                the the weights vector</p>
                            <p>This function loops through the matrix starting at row 1 because on row 0 the neutral face is loaded.
                                In every loop the neutral face (row 0) is subtracted from the rest of the faces. Afterwards the
                                transpose of the matrix is multiplied with the weights vector this will result in a vector that contains
                                new vertices, these vertices will be used to draw the resulting face.
                                The same function is used for the normals to get a vector that contains the normal of the new face.</p>
                            <p>For the animation part a special ImGUI button has been created called Run Animation.</p>
                            <p>A delay is implemented between every frame that is displayed, so the delay works by going to the next line of the matrix only after a certain
                                time.</p>
                            <p>For the vertex picking part two functions were used one for calculating the ray direction and one for
                                finding the intersections with the triangles in the object. The ray picking function was implemented
                                from Anton Gerdelan’s tutorials. It actually finds the direction of a ray from the mouse coordinates
                                to the object in viewport space.</p>
                            <a class="proj-github-lnk" href="https://github.com/ruxi-marcu/A1_BLEND_FACES"><i class="fab fa-github"></i> SOURCE CODE</a>
                            <!-- <li><a href="https://github.com/ruxi-marcu"><i class="fab fa-github"></i></a></li> -->
                        </div>
                        <div class="cg-proj-video">
                            <img src="./a1_blend_faces.png" />
                            <!-- <iframe src="https://www.youtube.com/embed/qvgyfhniP04" frameborder="0" allow="accelerometer;
                              autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
                            </iframe> -->
                        </div>
                    </div>
                </div>

                <!-- PLANE -->
                <div class="each-proj">
                    <div class="cg-proj-headline">PLANE</div>
                    <div class="proj-contents">
                        <div class="cg-proj-desc">
                            <p>There is a hierarchical structure implemented between the plane and the propeller so the propeller can spin independently of the plane's movement.</p>
                            <p>The model can be rotated by using Euler angles and quaternions.</p>
                            <p>The Gimbal lock for the euler angles can be achieved by doing a 90 degree roll and then a 90 degree
                                pitch. After making these rotations one degree of freedom is lost and the plane loses the ability to to
                                make a yaw rotation using Euler angles.</p>
                            <p>The program implements a third person camera and a first person camera.</p>
                            
                            <a class="proj-github-lnk" href="https://github.com/ruxi-marcu/A2_PLANE"><i class="fab fa-github"></i> SOURCE CODE</a>
                        </div>
                        <div class="cg-proj-video">
                            <img src="./a2_plane.png" />
                            <!-- <iframe src="https://www.youtube.com/embed/qvgyfhniP04" frameborder="0" allow="accelerometer;
                              autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
                            </iframe> -->
                        </div>
                    </div>
                </div>
    
                
                
            </div>
        </div>
    
    </section>

    <footer></footer>

    <!-- JQUERY  -->
    <script src="https://code.jquery.com/jquery-3.5.1.js"
        integrity="sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=" crossorigin="anonymous">
        </script>
    <!-- LOAD HEADER AND FOOTER  -->
    <script src="../UTIL/load_header_footer.js"></script>
</body>

</html>
